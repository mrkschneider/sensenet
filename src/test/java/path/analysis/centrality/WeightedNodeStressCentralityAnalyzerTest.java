package path.analysis.centrality;

import java.util.Arrays;
import java.util.List;

import com.tcb.sensenet.internal.app.AppColumns;
import com.tcb.sensenet.internal.path.analysis.centrality.NodeCentralityAnalyzer;
import com.tcb.sensenet.internal.path.analysis.centrality.WeightedNodeBetweennessCentralityAnalyzer;
import com.tcb.sensenet.internal.path.analysis.centrality.WeightedNodeStressCentralityAnalyzer;
import com.tcb.sensenet.internal.path.analysis.centrality.distance.InverseWeightDistanceStrategy;
import com.tcb.sensenet.internal.path.analysis.centrality.distance.PassthroughEdgeDistanceStrategy;
import com.tcb.sensenet.internal.path.analysis.centrality.weight.accumulation.ColumnSumWeightAccumulationStrategy;
import com.tcb.sensenet.internal.path.analysis.centrality.weight.accumulation.UniformWeightAccumulationStrategy;
import com.tcb.sensenet.internal.path.analysis.centrality.weight.negative.IgnoreNegativeValuesStrategy;

public class WeightedNodeStressCentralityAnalyzerTest extends WeightedNodeBetweennessCentralityAnalyzerTest {
	
	@Override
	protected List<Double> getRefUnweightedCentralities() {
		// ref generated by R 3.1.1 statnet versions: network_1.13.0 sna_2.3-2 
		List<Double> ref = Arrays.asList(6.,1.,1.,3.,12.,1.,5.,10.,1.,16.);
		return ref;
	}

	@Override
	protected List<Double> getRefWeightedCentralities() {
		/* TODO WARNING: no external ref yet
		* Same result as for weighted node betweenness centrality in this case - this makes sense
		* as b.c. is calculated as shortest paths between nodes i,j involving node k divided by the total 
		* number of shortest paths between i,j. For small networks using weights as edge distances, it is
		* likely that there is only a single shortest path between i,j.  
		 */
		List<Double> ref = Arrays.asList(2.0, 0.0, 0.0, 0.0, 20.0, 0.0, 12.0, 8.0, 5.0, 5.0);
		return ref;
	}

	@Override
	protected NodeCentralityAnalyzer getUnweightedAnalyzer() {
		WeightedNodeBetweennessCentralityAnalyzer analysis = new WeightedNodeStressCentralityAnalyzer(
				new UniformWeightAccumulationStrategy(),
				new PassthroughEdgeDistanceStrategy(),
				new IgnoreNegativeValuesStrategy());
		return analysis;
	}

	@Override
	protected NodeCentralityAnalyzer getWeightedAnalyzer() {
		WeightedNodeBetweennessCentralityAnalyzer analysis = new WeightedNodeStressCentralityAnalyzer(
				new ColumnSumWeightAccumulationStrategy(AppColumns.WEIGHT.toString(), getRefNetwork().getNetwork()),
				new InverseWeightDistanceStrategy(),
				new IgnoreNegativeValuesStrategy());
		return analysis;
	}

}
