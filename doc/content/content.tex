\begin{document}

\title{SenseNet Manual}
\date{Version \input{settings/version}}
\maketitle

\clearpage

\tableofcontents
\clearpage

\section{Introduction}
SenseNet (``Structure ENSEmble NETworks'') maps structure ensembles of biomolecules to atom interaction networks and provides functions for their analysis and visualization. It is available as a plugin for the free network visualization software \textit{Cytoscape} \cite{Cytoscape}. 

Protein structures are frequently analysed to gain insights into the effects of ligand binding, residue mutations or conformational changes. In contrast to isolated structures generated by crystallography or other experimental sources, ensembles obtained from Molecular Dynamics (MD) provide additional information such as interaction lifetimes or correlation between conformations, allowing to investigate dynamic properties of biomolecules. In a structure ensemble network, each node represents one or a group of atoms while edges correspond to the interactions between these atoms (e.g. hydrophobic contacts or hydrogen bonds). Each edge is associated with a 'timeline' which indicates the presence of an interaction for each structure in the ensemble. Analysis functions are provided to extract information from these timelines and map results to network nodes and edges. Finally, SenseNet offers comprehensive visualization functions for side-by-side analyses of networks and 3D structures. 

\section{Installation}
\label{sec:installation}

The recommended method for obtaining SenseNet is the Cytoscape App Store or alternatively from our website at \url{https://bioinformatics.wzw.tum.de}. The latter option requires you to install the plugin manually. To do this, place the 'SenseNet' .jar file into the 'CytoscapeConfiguration/3/apps/installed' folder. Make sure to remove any old version of SenseNet from this folder before starting Cytoscape.

\section{Data model}

SenseNet maps protein or other macromolecular structures to a network of nodes, which correspond to individual atoms or groups of atoms, and edges, representing interactions between atoms. Atoms may be grouped into a 'metanode'; the individual atom nodes that are contained in this group are hence called its 'subnodes'. In a network, either a metanode or its subnodes may be 'active' (i.e. present) at a given time. This is achieved by expanding (replacing a metanode by its subnodes) or collapsing (replacing all subnodes by their metanode). The metanodes of a network can be expanded or collapsed by a double click, and all analysis methods which act on the 'active' set of nodes and edges take the current state of the network into account. For example, an analysis can be performed while some selected residues are expanded into individual atom nodes, while other residues are represented by a single node. When collapsing subnodes, all edges connecting to these nodes are replaced by metaedges which represent the cumulative interactions of the replaced edges. Separate metaedges are created for each interaction type (e.g. contacts or hydrogen bonds). A detailed description of edge sets and how they change can be found in section \ref{sec:edge_op_def}.

In order to model a structure ensemble, each edge is associated with a timeline represented as either a vector of integer values (e.g. presence or absence of contacts in each time frame) or a vector of real numbers (e.g. interaction energies). The timeline of a metaedge is called a 'metatimeline' and is calculated from its subedge timelines. The 'Sum' and 'Occurrence' frame weight methods yield two different metatimeline variants

\begin{equation}
  \label{eq:metatimelines}
  \begin{split}
    X_{ijk,sum} &= \sum_{\alpha \in i} \sum_{\beta \in j} X_{\alpha \beta k} \\
    X_{ijk,occ} &= \text{min}(1,X_{ijk,sum})
  \end{split}
\end{equation}

in which $X$ corresponds to a timeline, $i,j$ are metanodes, $k$ is an interaction type and $\alpha ,\beta$ are subnodes of $i,j$.

The weight of an edge describes the strength of an interaction. It is determined by the 'Timeline weight method', which is by default the average over all time frames. Alternatively, users can set the network to any single time frame or use averages of time blocks, e.g. as obtained from clustering. 

Difference networks can be used to compare networks of two similar, but different ensembles (e.g. structures with one or more point mutations). A difference network is created by mapping interactions between equivalent atoms of two networks onto each other. Two atoms are considered equivalent if they have the same chain name, residue index, residue inset, residue alternative location and atom name (see PDB specification \cite{PDB}). Notably, the residue name is not compared in order to allow comparisons for residue point mutations. All interactions between two equivalent atoms which have the same interaction type are considered equivalent. Interactions for which no equivalent can be found are compared to an empty timeline of all zeroes. Once all equivalent interactions are mapped, the timeline vectors are subtracted element-wise

\begin{equation}
    X_{\alpha \beta k,diff} = X_{\alpha \beta k} - X_{\alpha \beta k,ref}
\end{equation}

where $X_{\alpha \beta k}$ is the timeline of the compared network, and $X_{\alpha \beta k,ref}$ is the timeline of the reference network. Metatimelines are calculated analogously to eq. \ref{eq:metatimelines}.

\clearpage
\section{User Guide}

All plugin functions can be accessed via the Cytoscape GUI. The controlling elements can be found either in the 'SenseNet' tab on in the control panel or in the top menu within 'Apps - SenseNet'.

\subsection{General}

\paragraph{Import network}

\textit{Parameters}
\begin{itemize}
\item \textbf{Import networks} Choose one or more input sources to import. Use the plus and minus buttons to add/remove fields. See also section \ref{sec:file_formats} for more details on some of the file formats.
  \begin{itemize}
    \item \textbf{Input type}
  \begin{itemize}
  \item \textbf{AIF file} Import network from an AIF (Atom Interaction Format) .aif/.zaif file.
    \begin{itemize}
    \item \textbf{.aif/.zaif file} Input file: Either in AIF or compressed ZAIF format.
    \item \textbf{Frame sieve} Read only every nth frame. Useful to save memory.
    \item \textbf{Skip timelines} Skip timeline depending on a threshold. For example the 'Skip timelines $<$ 0.05 avg.' option does not import a timeline if its average is below 0.05.
    \end{itemize}
  \item \textbf{CPPTRAJ H-bonds} Import network from CPPTRAJ \cite{CPPTRAJ} hbond command output.
    \begin{itemize}
    \item \textbf{H-bond file} Generated by 'avgout'.
    \item \textbf{Timeline file} Generated by 'uuseries'.
    \item \textbf{Interaction type} Interaction type name.
    \item \textbf{Ignore backbone} Choose to ignore contacts involving backbone atoms (atom names C,O,N,CA).
    \item \textbf{Frame sieve} Same as for 'AIF file'.
    \item \textbf{Skip timelines} Same as for 'AIF file'.
    \end{itemize}
  \item \textbf{CPPTRAJ nativecontacts} Import network from CPPTRAJ nativecontacts output.
    \begin{itemize}
    \item \textbf{Contacts file} Generated by 'writecontacts'.
    \item \textbf{Native timeline file} Generated by 'seriesout'.
    \item \textbf{Nonnative timeline file} Generated by 'seriesnnout'.
    \item \textbf{Contacts .pdb file} Generated by 'contactpdb'.
    \item \textbf{Interaction type} Interaction type name.
    \item \textbf{Ignore backbone} Choose to ignore contacts involving backbone atoms (atom names C,O,N,CA).
    \item \textbf{Ignore intra-residue} Choose to ignore contacts within the same residue. 
    \item \textbf{Frame sieve} Same as for 'AIF file'.
    \item \textbf{Skip timelines} Same as for 'AIF file'.
    \end{itemize}
  \item \textbf{PDB structure H-bonds} Import network from H-bonds found in a PDB file. Hydrogens are required to find H-bonds. All atoms in the PDB file whose names start with 'H' are considered hydrogens.
    \begin{itemize}
    \item \textbf{PDB file} Select .pdb file to load.
    \item \textbf{Distance cut-off} Maximum donor-acceptor distance.
    \item \textbf{Angle cut-off} Minimum donor-hydrogen-acceptor angle.
    \item \textbf{Donor mask} Atom mask for donor atoms (see mask reference in section \ref{sec:atom_masks}).
    \item \textbf{Acceptor mask} Atom mask for acceptor atoms (see mask reference in section \ref{sec:atom_masks}).
    \item \textbf{Interaction type} Interaction type name.
    \end{itemize}
  \item \textbf{PDB structure contacts} Import network from contacts found in a PDB file.
    \begin{itemize}
    \item \textbf{PDB file} Select .pdb file to load.
    \item \textbf{Distance cut-off} Maximum contact distance.
    \item \textbf{Atom mask} Atom name mask to calculate contacts for (see mask reference in section \ref{sec:atom_masks}).
    \item \textbf{Interaction type} Interaction type name.
    \item \textbf{Ignore backbone} Choose to ignore contacts involving backbone atoms (atom names C,O,N,CA).
    \item \textbf{Ignore intra-residue} Choose to ignore contacts within the same residue. 
    \end{itemize}
  \item \textbf{DSSP secondary structure} Import network of secondary structure elements. All residues belonging to the same secondary structure element (helix/sheet) are connected sequentially.
  \item \textbf{DSSP file} Select .dssp file to load.
  \item \textbf{Interaction type} Interaction type name.
  \end{itemize}
\end{itemize}

\item \textbf{Difference network} Check box to select input files for creating a difference network. When checked, the 'Import reference networks' panel will appear. The differences are calculated by subtracting the timelines of equivalent interactions of the reference network from the network loaded in the top import panel (\textbf{Import networks}).  

\item \textbf{Metanode definition} Choose how atom nodes are grouped together.
  \begin{itemize}
    \item \textbf{Group definition} Grouping settings.
  \begin{itemize}
  \item \textbf{Amino acids} Group atoms by their respective amino acids
  \item \textbf{Backbone/Sidechain} Group atoms by their respective amino acids, but create seperate nodes for the backbone/sidechain portions. The \textbf{Backbone atom names} text field contains all atom names that will be categorized as backbone, separated by commas.
  \end{itemize}
\end{itemize}

\item \textbf{Network options}
  \begin{itemize}
  \item \textbf{Create visual style} Check to automatically create a new visual style for the network.
  \item \textbf{Network name} Displayed name of the network. Automatically filled when imported files are chosen. Can also be set manually.
  \item \textbf{Remove edges} Setting to remove (deactivate) edges below a certain threshold. Equivalent to the setting with the same name in the 'Interaction weights' tab. Can be changed at any time.
  \end{itemize}
\end{itemize}
\paragraph{Show log} Show task logs.
  
\textit{Parameters}
\begin{itemize}
\item \textbf{Log category} Select log category to display.
  \begin{itemize}
    \item \textbf{Global} Continuous list of task logs since session start.
    \item \textbf{Task} Last log of task type selected in the \textbf{Log type} box.
   \end{itemize}
\end{itemize}
  
\paragraph{Export network} Export current network in AIF format. The exported file can e.g. be used for importing a multisource network as a single file containing the combined information of all original import files. 
    
\subsection{Shown interactions}

Only interaction types with checked boxes are shown in the network. The interaction type of each edge is read from the \textbf{shared interaction} column. 

\subsection{Interaction weights}
\label{sec:weight_methods}
This panel controls how individual atom timelines are combined into metatimelines. The radio buttons on the left chooses how each frame of the metatimeline is determined ('Frame weight method'; see eq. \ref{eq:metatimelines}). The buttons on the right select how to determine the total weight of the metatimeline ('Timeline weight method'):

\begin{itemize}
\item \textbf{Average weight} Average over all frames in the timeline
\item \textbf{Single frame} Select and show the network state at an individual time frame
\item \textbf{Clusters} Show average of frames within a cluster. Requires previous clustering analysis
\end{itemize}

Weighting is performed on all imported edges (see section \ref{sec:edge_op_def} for an explanation of edge sets). For metaedges, all subedges of the same interaction type are considered. Whenever weighting is performed, the results are written into the 'weight' and 'standard deviation' edge columns.

\subsection{Analysis}

\subsubsection{Network interactions}
\label{sec:network_interactions}
The analysis functions in this panel act on the whole network. Results are usually presented as tables/plots in the result panel on the right.

\paragraph{Timeline}

Shows the timelines for all imported edges. For metaedges, the metatimeline is calculated according to the selected weight method.

\textit{Parameters}
\begin{itemize}
\item \textbf{Frame weight} Method for determining metatimelines. See section \ref{sec:weight_methods}
\end{itemize}


\paragraph{Degree}

Calculates weighted degree for active edges. Results are written into the 'degree' node table column.

\textit{Parameters}
\begin{itemize}
\item \textbf{Degree weight} Method for calculating weights for adjacent edges.
  \begin{itemize}
  \item \textbf{Edge weight sum} Sum values of edge columns.
  \end{itemize}
\item \textbf{Weight column} Source column for edge weights.
\item \textbf{Negative weights} Method to treat negative edge weights.
  \begin{itemize}
  \item \textbf{abs(x)} Use absolute value of x.
  \end{itemize}
\end{itemize}

\paragraph{Centrality} Calculate weighted centrality measures for active nodes, based on shortest paths. The algorithms are implemented as described in refs. \cite{Brandes2008,delSol2006}. If two nodes are connected by multiple edges, they are treated as one, using one of several merging methods. Results are written into the 'centrality' node table column.

\textit{Parameters}
\begin{itemize}
\item \textbf{Centrality type} Centrality measures to compute. A transformation function maps edge weights to determine the distance between nodes (see algorithm 10 in ref. \cite{Brandes2008})
\item \textbf{Multiple edges weights} Method for merging parallel edges between two nodes. 
  \begin{itemize}
  \item \textbf{Sum/Min/Max} Use the weight sum/average/min/max of parallel edges as total weight. 
  \item \textbf{Edge count} Use the number of edges between two node pairs as total weight. 
  \item \textbf{Uniform} All edges are assigned an uniform weight. Parallel edges are ignored. This option effectively gives the centralities of an unweighted network.
  \end{itemize}
\item \textbf{Weight column} Column of edge weights. 
\item \textbf{Distance transformation} Function to transform edge weights to distances. The function is commonly chosen such that a high weight corresponds to a low distance.
\item \textbf{Negative weights} Method to treat negative edge weights.
\item \textbf{Normalization} Type of normalization to apply to centrality values.
  \begin{itemize}
  \item \textbf{None} Do not perform normalization.
  \item \textbf{Min-max range} Subtract the minimum centrality of the network from each value and divide by the range of values. The normalized value is limited between 0 (lowest centrality) and 1 (highest centrality).
    \item \textbf{Max node pairs} Divide each node's centrality by the theoretical maximum number of node pairs, excluding that node, in an undirected network: $\frac{(N-1)(N-2)}{2}$, where $N$ is the total number of active nodes.
  \end{itemize}
\end{itemize}

\paragraph{Correlation}

Determine correlation between \textbf{active} edges. The edge neighbour correlation factor $\textrm{ECF}$ is calculated as

\begin{equation}
  \label{eq:edge_corf}
  \textrm{ECF(i)} = \sum_{j \in A} |c(i,j)|
\end{equation}

where $i,j$ are network edges, $c(i,j)$ is a correlation function of edges $i$ and $j$, and $A$ is the set of edges that $i$ is compared to. Correlation factor types may use different edge sets for $A$.

\textit{Parameters}
\begin{itemize}
\item \textbf{Correlation factor type}
  \begin{itemize}
  \item \textbf{Neighbour} Edge neighbour correlation factor. Here, $A$ is the set of edges adjacent to $i$ (i.e. separated by at most one node)
    \end{itemize}
\item \textbf{Correlation method} Correlation measure to use (see text below).
\item \textbf{Frame weight} Method for determining metatimelines. See section \ref{sec:weight_methods}.
\item \textbf{Reference network} For methods calculating correlation differences.
\item \textbf{Edge mapping} Determine how edges are matched between active and reference networks.
  \begin{itemize}
  \item \textbf{Shared name} Match edges with identical 'shared name' entries in the edge table.
  \item \textbf{Match location} Require that the 'shared name' entries of source and target nodes approximately match between networks. The approximation is that only the 'residue name' is allowed to differ. The 'altloc' and 'residue insert' identifiers are not considered part of the residue name and thus still have to be identical. This option is intended for comparing two networks differing e.g. in point mutations of single residues in order to match edges representing conserved interactions.
  \end{itemize}
\end{itemize}

The 'Mutual information' correlation method determines correlation as 

\begin{equation}
I(X;Y) = \sum_{x \in X} \sum_{y \in Y} p(x,y) \log_2 \left(\frac{p(x,y)}{p(x)p(y)}\right) 
\end{equation}

in which, $X$ and $Y$ are \textbf{integer} timelines, $p(x,y)$ is the joint probability function of values $x,y$, and $p(x),p(y)$ are marginal probability functions of $x,y$. This method should be used when the timeline contains discrete values, such as the count of interactions. The unit for mutual information results is 'bits'.

'Mutual information difference' calculates the sum of absolute changes in expected pointwise mutual information for each event

\begin{equation}
\begin{split}
  I(X;Y) = \sum_{x \in (X \bigcup \hat{X})} \sum_{y \in (Y \bigcup \hat{Y})} \Bigm| p(x,y) \log_2{\left(\frac{p(x,y)}{p(x)p(y)}\right)} \\
  - \hat{p}(x,y) \log_2{\left(\frac{\hat{p}(x,y)}{\hat{p}(x)\hat{p}(y)} \right)} \Bigm| 
\end{split}
\end{equation}

where the $\hat{X},\hat{Y}$ denote timelines in the reference network corresponding to $X,Y$. Edges are considered equivalent if their 'shared name' columns match. If no match can be found for an edge, the reference timeline is replaced by a vector of zeroes. This measure is useful for determining differences in dynamic behaviours between simulations, f.e. a protein with and without a ligand. 

Alternatively, choosing the 'Pearson' correlation method will calculate the Pearson correlation coefficient between interaction timelines

\begin{equation}
  r = \frac{\sum_{i} (X(i) - \mu_x)(Y(i) - \mu_y)}{\sigma_x \sigma_y}
 \end{equation}

where $i$ is a discrete time frame, $X(i),Y(i)$ are functions yielding the corresponding timeline value at position $i$, with associated sample means $\mu$ and standard deviations $\sigma$. This method is recommended when the timeline contains continuous values like interaction energies. 

The resulting correlation factors for each edge are written into the 'correlation factor' column.

\paragraph{Lifetime}

Calculates estimates for the interaction lifetimes. These are calculated from the intermittent autocorrelation function

\begin{equation}
  \label{eq:lifetime_autocorrelation}
     C_L(k) = \frac{1}{N} \sum_{i=0}^{N-k} \frac{X_{occ}(i) X_{occ}(i+k)}{X_{occ}(i)^2}
\end{equation}

in which $k$ is the discrete lag step, $N$ is the total number of time frames and $X_{occ}(i)$ is the occurrence weighted metatimeline function. The calculated lifetime is intermittent, i.e. the interaction may break and reform between the compared time frames. The average lifetime is estimated from the autocorrelations following the same protocol as for the autocorrelation time during error estimation.

If the 'Replicas' setting is set to $n > 1$, the timeline is divided into $n$ equal sized blocks, which are analyzed separately. The average of block lifetimes is written to the 'lifetime' edge column.

\paragraph{Weight error}
\label{sec:weight_error}
Calculates weight error estimates for all imported edges. These functions aim at approximating the standard error of the timeline weight.

\textit{Parameters}
\begin{itemize}
\item \textbf{Error method} Method for calculating the error. Currently, only 'Autocorrelation' is available.
\item \textbf{Frame weight} Method for determining metatimelines. See section \ref{sec:weight_methods}.
\item \textbf{Replica weight} Method to merge errors from multiple replicas.
  \begin{itemize}
    \item \textbf{Max/Avg/Min} Use maximum, average or minimum of replicas as final error value.
   \end{itemize}
\end{itemize}

The autocorrelation method is based on the approach outlined in ref. \cite{Grossfield2009}. The timeline autocorrelation for different discrete lag steps is calculated as

\begin{equation}
  \label{eq:autocorrelation}
     C(k) = \frac{1}{N\sigma^2} \sum_{i=0}^{N-k} (X(i) - \mu) (X(i+k) - \mu)
\end{equation}

with $k$ as the discrete lag step, $N$ as the total number of time frames, $X(i)$ as the timeline function at each discrete time frame, $\mu$ as the mean of $X$, and $\sigma^2$ as the variance of $X$. A single exponential of the form $A * e^{Bx}$ is fitted by weighted linear regression in log space with weights $\frac{1}{k+1}$. To reduce the influence of noisy function tails, only autocorrelation values above 0.1 are considered for fitting. The integral of the fitted exponential is calculated analytically and serves as estimate for the autocorrelation time $\tau$. The estimate for the independent sample size is then determined as

\begin{equation}
  \label{eq:independent_sample_size}
  N_{ind} = \frac{N}{\tau}
\end{equation}

which is used to estimate the standard error of independent samples

\begin{equation}
  \label{eq:standard_error_independent}
  \sigma_{e,ind} = \frac{\sigma}{\sqrt{N_{ind}}}
\end{equation}

If the 'Replicas' setting is set to $n > 1$, the timeline is divided into $n$ equal sized blocks, which are analyzed separately. The final error is determined as by the 'Replica weight method'.

The results of this analysis are written into the 'error estimate', 'autocorrelation sample size', and 'autocorrelation time' edge columns. 

\paragraph{Entropy}
\label{sec:entropy}

For each network edge, determine Shannon's information entropy

\begin{equation}
  \label{eq:shannon_entropy}
  H(X) = -\sum_{x \in X} p(x) \log_2 (p(x))
\end{equation}

where $X$ is the edge's integer interaction timeline. Results are written into the 'entropy' edge column. The unit of reported results is 'bits'.

\textit{Parameters}
\begin{itemize}
\item \textbf{Frame weight} Method for determining metatimelines. See section \ref{sec:weight_methods}.
\end{itemize}

\begin{comment}
\paragraph{Divergence}
\label{sec:divergence}

Quantifies differences between edge metatimelines of individual replicas. These functions are intended to be used with integer timelines to provide quality control for simulation runs. The statistical error of of many simulation setups depends on the convergence of analysed properties (see e.g. ref. \cite{Grossfield2009} for a more detailed discussion). Convergence in the context of interaction networks implies that the timelines of individual replicas should have similar probability distributions and kinetics. Edge with high divergence scores indicate that these properties differ between replicas, and therefore the simulation is not yet converged in the region surrounding these edges. Note that this method cannot prove that a simulation has converged, only pick up signs of when it is not. 

Each timeline is split into its corresponding replica blocks and the divergence is calculated as

\begin{equation}
  \label{eq:divergence}
  D(T) = \frac{1}{N} \sum_{i \neq j} d(X_i,X_j)
\end{equation}

where $N$ is the count of replica blocks, $d$ is the selected divergence method (see below) and $X_i$ is the discrete probability distribution of values contained in block $i$ of metatimeline $T$.

\textit{Parameters}
\begin{itemize}
\item \textbf{Divergence method} Method for calculating divergence between replicas. 
  \begin{itemize}
  \item{\textbf{Kullback-Leibler symm.} Divergence is determined as the symmetrized Kullback-Leibler divergence
    \begin{equation}
      d_{KL,symm}(P,Q) = d_{KL}(P,Q) + d_{KL}(P,Q)
    \end{equation}
    where $P,Q$ are discrete probability distributions and $d_{KL}$ is the Kullback-Leibler divergence
    \begin{equation}
      \label{eq:kullback-leibler-divergence}
      d_{KL}(P,Q) = \sum_{x \in P \cup Q} P(x) \log_2{\frac{P(x)}{Q(x)}}
    \end{equation}
    with $P(x),Q(x)$ as the probabilities of value $x$ in $P,Q$. The output unit is 'bits' and the possible range of values extends from 0 to positive infinity.}
  \item{\textbf{Jensen-Shannon} Calculate divergence as
    \begin{equation}
      \label{eq:jensen-shannon-divergence}
      d_{JS}(P,Q) = \frac{1}{2} d_{KL}(X,M) + \frac{1}{2} d_{KL}(Y,M)
      \end{equation}
    where $P,Q$ are discrete probability distributions and $M$ is the average distribution of $P,Q$. As for the Kullback-Leibler divergence, the resulting unit is 'bits', but results are limited to the range between 0 and 1.}
  \item{\textbf{Population shift} Calculate distance between probability distributions as the total variation distance
    \begin{equation}
      \label{eq:population-shift-divergence}
      d_{PS}(P,Q) = \frac{1}{2} \sum_{x \in P \cup Q} |P(x) - Q(x)| 
    \end{equation}
    with $P(x),Q(x)$ as the probabilities of value $x$ in $P,Q$. A possible interpretation of this distance is the average population fraction to be shifted to turn distribution P into Q or vice versa. Results fall in the range between 0 and 1.}
  \end{itemize}
  
\item \textbf{Frame weight} Method for determining metatimelines. See section \ref{sec:weight_methods}.
\item \textbf{Convergence limit} Target minimum divergence for extrapolating convergence time.
\end{itemize}

Divergence scores for each edge are written into the 'divergence' edge column. In addition, the function calculates progression of the divergence score with increasing simulation time and extrapolates the convergence point (defined as the time when divergence drops below the convergence limit) using a single exponential fit. The extrapolated convergence time is written into the 'convergence time' edge column. 
\end{comment}

\subsubsection{Selected interactions}

Show detailed analyses for one or more selected edges.

\paragraph{Timeline} Equivalent to the corresponding function in section \ref{sec:network_interactions}, but shows a plot of the timeline using the currently active frame weight method.

\paragraph{Correlation} Calculates correlation measures between a single selected edge and all other imported edges (see section \ref{sec:network_interactions}). 

\paragraph{Autocorrelation} Equivalent to the corresponding function in section \ref{sec:network_interactions}. Uses the currently active frame weight method and plots autocorrelation functions for each selected edge.

\paragraph{Blocked error} Plots the blocked standard errors following a procedure from ref. \cite{Grossfield2009}. Uses the currently active frame weight method.

In essence, the standard error (see eq. \ref{eq:standard_error_independent}) is calculated multiple times between blocks of time frames. For the minimum block size of 1, the result is the conventional standard error. For a block size of 2, each time frame is averaged with its successor yielding $\frac{n}{2}$ non-overlapping 'block averages', where $n$ is the total number of time frames. The standard error is then calculated between these block averages as if each was an independent data point. This is repeated for increasing block sizes. The maximum block size is set as $\frac{n}{4r}$, where $n$ is the total number of time frames and $r$ is the number of replicas. The total standard error can be estimated from the plot as the value to which the blocked standard errors converge.

\begin{comment}
\paragraph{Divergence} Plots average divergence scores between replicas against simulation time as described in section \ref{sec:divergence}.
\end{comment}

\subsubsection{Network matrix}

These functions allow plotting and exporting networks in matrix form.

\paragraph{Show} Display matrix of active network edges as a dotplot.

\textit{Parameters}
\begin{itemize}
\item \textbf{Weight column} Select column to use for weighting.
\item \textbf{Node index column} Select column to use as indices for the X and Y axes of the plot. Only columns of integers are allowed.
\item \textbf{Min/Max value} Set min and max value for weight color scale.
\end{itemize}

\paragraph{Export} Export matrix of active network edges. 

\textit{Parameters}
\begin{itemize}
\item \textbf{Weight column} Select column to use for weighting.
\item \textbf{Node name column} Select column to use as names for the X and Y axes of the plot.
\item \textbf{Output file} File to write matrix to.
\end{itemize}

\subsubsection{Paths}

The following functions provide functions for the identification of pathways between two selected nodes.

\paragraph{Shortest paths} Find all shortest paths by traversing active edges between two selected nodes, starting from the node that was selected first. Edges are considered to represent equal distances, and parallel edges are ignored. The paths are presented in a table in the result panel. In addition, two measures of interaction strength are shown: The 'timeline sum' is the sum of average interactions of edges contributing to the pathway. In contrast, 'timeline occurrence' gives the average occurrence weights along that path. If multiple edges are present between two nodes, they are treated as if their timelines were merged.

\paragraph{Suboptimal paths} Find all paths of a fixed length range between two nodes. Only active edges are considered and all edges are assumed to represent the same distance. Minimum and maximum path lengths can be set as parameters. Otherwise, output is equivalent to the 'Shortest paths' function.

\subsubsection{Clustering}

From this panel, functions for clustering of time frames can be accessed.

\paragraph{Cluster} Start a new clustering run, grouping time frames with similar network states until a limit is reached. For this purpose, each time frame in the network is represented by an interaction matrix of dimension $N \times N$, where $N$ is the number of nodes. Each entry in the matrix corresponds to the selected weight. If multiple edges are present between two nodes, their weights are summed. The distance between two time frames is calculated as the Frobenius norm of their matrix differences. This set of distances is then used for clustering.

\textit{Parameters}
\begin{itemize}
\item \textbf{Clustering method}
  \begin{itemize}
    \item \textbf{Agglomerative} Hierarchical agglomerative clustering.
    \item \textbf{Linkage} Select linkage mode for agglomerative clustering.
    \end{itemize}
  \item \textbf{Target cluster count/Epsilon} Select to stop clustering either at N clusters or when the minimum intercluster distance drops below a certain limit.
  \item \textbf{Sieve} Select to use only every Nth frame for clustering.
  \item \textbf{Frame weight} Select weight mode for the frame interaction matrix. See section \ref{sec:weight_methods}.
    \end{itemize}
      
      
\subsection{Structure visualization}

This panel contains functions to connect Cytoscape to a 3D structure viewer session. Networks can be linked to structures or trajectories loaded in the viewer. Node and edge selections in a linked network are highlighted in the structure. 

\paragraph{Connect viewer} Start a structure viewer and connect to it.

\textit{Parameters}
\begin{itemize}
  \item \textbf{Viewer} Select one of the available viewers to start (VMD, PyMOL or UCSF Chimera). See section \ref{sec:installation} for viewer installation requirements.
  \item \textbf{Load session} Select a session file for the viewer to load after starting. 
\end{itemize}

\paragraph{Model link} Shows whether the currently focused network is linked to a structure.

\paragraph{Link network} Link current network to a structure in the connected viewer.

\textit{Parameters}
\begin{itemize}
\item \textbf{Single structure} Load a single structure into the viewer and link the network to it.
  \begin{itemize}
  \item \textbf{Structure file} Select file to load structure from.
  \item \textbf{Format} Automatically determined by structure file extension. Can be set manually. Available options depend on the connected viewer.
  \item \textbf{Model name} Model name to use for the structure. Must be unique.
  \end{itemize}
\item \textbf{Trajectory} Load a trajectory of structures into the viewer and link the network to it.
  \begin{itemize}
  \item \textbf{Structure file} Select file to load structure or topology from.
  \item \textbf{Format} same as in 'Single structure'. Depending on the connected viewer, topology formats are accepted as well.
  \item \textbf{Model name} same as in 'Single structure'.
  \item \textbf{Trajectory file} Select file to load trajectory from.
  \item \textbf{Trajectory format} same as 'Format', but for trajectories.
  \end{itemize}
\item \textbf{Preloaded} Link network to a structure already present in the viewer
  \begin{itemize}
  \item \textbf{Model name} Select model name in structure viewer to link network to.
  \end{itemize}
\end{itemize}

\paragraph{Unlink network} Remove structure link of the current network. An option is given to remove the structure from the viewer as well.

\paragraph{Pause link} Temporarily disable structure link of the current network. Until the link is unpaused, selection changes are not updated between network and structure viewer. 

\paragraph{Transfer colors} Color linked structure according to node colors in the network. For VMD and UCSF Chimera, the visually closest color of the defined color set is used. For PyMOL, the colors are transferred exactly as shown in the network.

\subsection{Style}

\subsubsection{Node style}
\label{sec:node_style}

\paragraph{Auto style} Map continuous node attributes to visual style. Creates a copy of the current style with a '\_auto' suffix. If a style with that name already exists, it will be overridden.

\textit{Parameters}
\begin{itemize}
\item \textbf{Style property} Select visual property to map values to. Different style settings are available for each property.
  \begin{itemize}
  \item \textbf{Color} Map node attribute to fill color.
    \begin{itemize}
    \item \textbf{Min/Mid/Max value} Minimum/Middle/Maximum value to map. Default values are determined automatically according the range of values in the network for the selected column.
    \item \textbf{Low/Mid/High color} Color gradient from low to high.
    \end{itemize}
  \item \textbf{Size} Map node attribute to node size.
  \item \textbf{Min/Max value} see 'Color'.
  \item \textbf{Min/Max size} Minimum/Maximum node size.
  \end{itemize}
\item \textbf{Column} Column to map values from. All columns containing 'Double' values can be chosen.
\end{itemize}

\paragraph{Label format} Select node label style. See section \ref{sec:labels} for an explanation of naming conventions. 
\paragraph{Renumber} Renumber residue indices in labels.

\textit{Parameters}
\begin{itemize}
\item \textbf{Chain} Chain(s) to renumber. Select one character ('A','B', etc.) or '*' to select all chains.
\item \textbf{First residue index} First residue index to renumber.
\item \textbf{Last residue index} Last residue index to renumber or '-1' to select up until and including the last residue index of selected chain(s).
\item \textbf{Offset} Offset to add to the selected residues. Can be positive or negative.
\end{itemize}

Note that renumbering always acts on the \textbf{original residue numbering}. Therefore, if you renumbered residue 1 to become residue 100, you would have to select residue index 1 again to renumber it a second time. In order to return all numberings to the original imported state, you can use the 'Reset numbering' button in the dialog.

Labeling and renumbering never changes the 'shared name' or 'residue index' columns. Instead, results are written into the 'label' and 'residue index label' columns in the node table. This is done to avoid accidental ambiguity and loss of data. See section \ref{sec:labels} for an explanation of the underlying concepts.

\subsubsection{Edge style}

\paragraph{Auto style} Analogous to the corresponding function in section \ref{sec:node_style}.

\subsection{Settings}

\paragraph{Structure viewer} Configuration for structure viewers
\begin{itemize}
\item \textbf{PyMOL/VMD/UCSF Chimera location} Location to search for respective executables. If no location is given, the plugin will attempt to run the displayed command from the operating system's PATH variable
\item \textbf{Max shown residues} Maximum number of residues to show as sticks before an error is thrown
\item \textbf{Max shown interactions} Maximum number of interactions highlighted before an error is thrown
\item \textbf{Selected interaction color} Highlight color for selected interactions
\item \textbf{Selected residue color} Highlight color for selected residues
\item \textbf{Zoom to selection} Check to enable auto-zoom to selected residues
\end{itemize}

\section{Concepts}

\subsection{Labels and identifiers}
\label{sec:labels}

Within the plugin, certain naming conventions are used to map nodes and edges to their structural counterparts. The standard naming style for nodes is

\textbf{\textless Chain\textgreater /\textless Altloc\textgreater \textless Residue name\textgreater \textless Residue insert\textgreater \\-\textless Residue index\textgreater (-\textless Mutated residue name\textgreater )(:\textless Atom name\textgreater )\\(\#\textless Group tag\textgreater )}

The standard naming style for edges is

\textbf{\textless Node name 1\textgreater \_\textless Bridge name\textgreater \_\textless Node name 2\textgreater\\ \_\textless Interaction type\textgreater}

The data fields correspond to the RCSB PDB \cite{PDB} standard\footnote{\url{http://www.wwpdb.org/documentation/file-format-content/format33/v3.3.html}}. 'Group tag' is used when a non-amino acid metanode definition is used (such as backbone / sidechain). 'Bridge name' is used for interactions that involve more than two atoms, for example the name of the hydrogen in a hydrogen bond interaction. For amino acids, three-letter codes are used for residue names, but longer names are possible. Empty fields are allowed. Field separators enclosed in parentheses will only appear if the corresponding field is filled. For edges with a bridge atom, node names 1 and 2 are the source and target nodes, respectively. If no bridge atom is present (e.g. in metaedges), the node names appear in alphabetical order. This is done to ensure that edge names are predictable for symmetric interactions. the An example for a standard node label is 'A/TYR-290', and for a standard edge label it is 'A/TYR-290\_\_A/VAL-80\_H-bond'. 

A node or edge 'name' (as found in the 'shared name' or 'name' columns) always follows the standard naming style, is assigned at import and is never changed. 'Names' are meant to identify edges as uniquely as possible, but \textbf{there is no guarantee that a name is unique in the network}. Node label customization functions create 'labels', which are allowed to omit information (such as chain names). Edge labels are automatically updated accordingly to the node labels. Labeling functions always write into separate 'label' columns.

\subsection{Atom masks}
\label{sec:atom_masks}

When importing networks using the plugin, sometimes a selection of atom names is needed. Whenever an 'atom mask' is required, a Java regular expression\footnote{\url{https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html}} needs to be provided. For most purposes, a tiny subset of the regular expression language is sufficient for a proper selection. Examples of often used patterns are

\begin{itemize}
  \item \textbf{.*} All atom names (. = any character, * = zero or more repetitions of the preceding character)
  \item \textbf{C.*} Atom names starting with C
  \item \textbf{F.*\textbar O.*\textbar N.*} Atom names starting with F,O, or N (\textbar\ = 'or')
\end{itemize}

\subsection{Network operations}
\label{sec:edge_op_def}

The number of nodes and edges currently present can change due to filtering or expanding/collapsing of metanodes. Hence, it is important for each function that deals with edges to define on which set it operates. The sets are defined as follows:

\begin{itemize}
\item \textbf{Active nodes/edges} All edges that are currently present in the network. This includes nodes that are present, but hidden from view (f.e. using Cytoscape's 'hide nodes' feature). A node or edge that becomes inactive is temporarily deleted from the network. When an inactive node/edge becomes active, it is restored.  
\item \textbf{Imported nodes/edges} All nodes/edges from the original import, regardless of whether they are active or not.
\end{itemize}

The following operations can render a node/edge active or inactive:
\begin{itemize}
\item \textbf{Expanding/Collapsing a metanode} The metanode and associated metaedges are deactivated. Subnodes and associated edges are activated.
\item \textbf{Edge weight filtering} Edges which are filtered out due to low weights are deactivated.
\item \textbf{Subnetwork creation} When subnetworks are created from selected nodes, the selected nodes become the active node set for that network.
\item \textbf{Manual deletion} Manually deleting nodes/edges f.e. using the 'DEL' key are deactivated, but can be reactivated f.e. when weight filtering is updated or a metanode is expanded/collapsed.
\end{itemize}

Generally, \textbf{the set of active nodes and edges is equivalent to the currently visible network}. Nodes and edges that are only hidden due to visualization (such as using Cytoscape's 'hide nodes/edges' feature) are still considered 'active' and part of the network. Inactive nodes are temporarily deleted from the network and are hence invisible both in the presentation and for network analysis algorithms. Hence, tools like NetworkAnalyzer or other analysis plugins can be used normally. 

\subsection{AIF file format}
\label{sec:file_formats}
The AIF (Atom Interaction Format) was created as a convenient way to define interaction networks based on timeline data. All lines start with a record indicator, followed by one or more comma-separated data fields. Interaction data may be given as TIMELINE and DIFFERENCE\_TIMELINE records, which define the following fields

\begin{itemize}
\item interaction type (string)
\item source atomname (string)
\item target atomname (string)
\item source residue index (int)
\item target residue index (int)
\item source residue name (string)
\item target residue name (string)
\item source residue insert (string)
\item target residue insert (string)
\item source altloc (string)
\item target altloc (string)
\item source chain (string)
\item target chain (string)
\item bridge names (whitespace delimited list of strings)
\item timeline (whitespace delimited list of ints/floats)
\end{itemize}

An AIF file must have the following properties:

\begin{itemize}
\item Lines are separated by Unix style newline ('Linefeed') characters.
\item A line consists of one or more fields, which are separated by a comma. Leading and trailing whitespace are ignored for each field. Fields may be empty.
\item The first field of each line denotes the record type. The record type defines how many fields follow in the same line and what their field data types are. The record type is case insensitive.
\item Lines starting with a '\#' character indicate comment lines and should be ignored by parsers.
\item Empty lines or lines that contain only whitespace should be ignored by parsers.
\item Tabs count as regular characters (not whitespace) and should be avoided entirely.
\end{itemize}

In order to save disk space, AIF files may be zipped (.zaif). 

\section{External tools guide}
\label{sec:external_tools}

The SenseNet plugin can interact with a number of programs. This section gives details on how to set up and use those programs together with the plugin.

\subsection{Command line interface}
\label{sec:cli}

In order to allow automatized workflows, SenseNet allows some of its functions to be called either via the Cytoscape automation console, script files or the CyREST interface. They fulfill the same purpose as their equally named GUI counterparts and are called by preceding them with the ``sensenet'' namespace tag (e.g. ``senseset importAif''). In addition, functions provide documentation by using the ``help'' command (e.g. ``help sensenet importAif''). Validity of input is checked after parsing the command and corresponding error messages will appear, spelling out problems and allowed input options.

\subsection{Structure viewers}

The plugin can interact with several structure viewers (PyMOL, VMD and UCSF Chimera) in order to map the network onto a molecule structure. In order to use the plugin together with one of these viewers, it is only necessary that the plugin can start the viewer. By default, it will attempt to look up the installation location from the operating system's PATH variable (equivalent to typing 'pymol','vmd' or 'chimera' on the command line). Alternatively, the installation location can be set manually in the 'Settings' menu. The viewer needs to be started using the 'Connect viewer' button in order to link a network.

The plugin was tested in combination with PyMOL 2.1.0, VMD 1.9.2 and UCSF Chimera 1.12. 

\subsection{CPPTRAJ}

CPPTRAJ \cite{CPPTRAJ} is part of the AmberTools program suite and can be used to process and analyze molecular dynamics trajectories. The following sections describe how to use CPPTRAJ to write interaction timeline data, which can be used to create interaction networks. The scripts were tested with the CPPTRAJ version contained in AmberTools17. 

\subsubsection{nativecontacts}
The following output files of the CPPTRAJ nativecontacts command are necessary for network import:

\begin{itemize}
\item \textbf{contacts.out} Contact table
\item \textbf{contacts.series} Timeline series for native contacts
\item \textbf{contacts.nonnative.series} Timeline series for non-native contacts
\item \textbf{contacts.pdb} PDB file as output by nativecontacts
\end{itemize}

These files can be created using the following CPPTRAJ commands (adjust \textbf{bold} arguments as necessary)

\fbox{
\parbox{\textwidth}{
parm \textbf{md.prmtop}\\
trajin \textbf{md.nc}\\
nativecontacts \textbf{@C*} distance \textbf{5.0} \textbackslash \\
\hspace*{2em} writecontacts contacts.out contactpdb contacts.pdb \textbackslash \\
\hspace*{2em} series seriesout contacts.series \textbackslash \\
\hspace*{2em} savenonnative seriesnnout contacts.nonnative.series \\
run
}}

\subsubsection{hbond}
The following output files of the CPPTRAJ hbond command are needed for importing a network:

\begin{itemize}
\item \textbf{hbonds.out} Interaction table
\item \textbf{hbonds.series} Interaction timeline series
\end{itemize}

These files can be generated by the following CPPTRAJ commands (adjust \textbf{bold} arguments as necessary)

\fbox{
\parbox{\textwidth}{
parm \textbf{md.prmtop}\\
trajin \textbf{md.nc}\\
hbond \textbf{!(:WAT,Na+,Cl-)} dist \textbf{3.5} angle \textbf{135} \textbackslash \\
\hspace*{2em} avgout hbonds.out \textbackslash \\
\hspace*{2em} series uuseries hbonds.series\\
run
}}

\section{Troubleshooting}

\subsection{Installation}
\begin{itemize}
  \item \textit{Could not find plugin for installation} Make sure that your current working directory contains the .jar file found in the zip archive
 \item \textit{Could not find Cytoscape app directory} Check whether Cytoscape is installed on your system. If you never started Cytoscape on your machine, try starting it once before installing the plugin. The CytoscapeConfiguration directory will be created on its first start.
 \end{itemize}

 \subsection{Session files}
Cytoscape offers to save the current working state in a .cys session file. The plugin is fully compatible with this function. However, reading session files generated with older versions of the plugin may fail. In general, you can expect session to work if the first two digits of the plugin version are identical. For example, a session created with version 1.2.0 is guaranteed to be readable by plugins of version 1.2.X, but not by version 1.1.0. 

\subsection{Slow analyses and 'out of memory' errors}
Keeping the full timelines of long trajectories consumes a lot of memory, especially for large systems. Reducing the amount of analysed time frames, e.g. by using the 'sieve' option in CPPTRAJ or during import, can accelerate analyses substantially. For a workstation with 8 GB RAM and a protein of about 200 amino acids, we found a number of ~ 5000 frames to work well.  

\subsection{Subnetworks and changes in node/edge tables}
It is often useful to create one or more subnetworks to analyze specific regions in the protein. It is important to remember that the node and edge data tables are shared between the network and all subnetworks. This means that an analysis performed in a subnetwork also changes the data tables in all other networks belonging to the same group. 

\clearpage
\addcontentsline{toc}{section}{References} 
\bibliography{content/references.bib}

\end{document}
